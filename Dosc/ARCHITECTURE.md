# Техническая архитектура String Art Generator

## Обзор алгоритма

String Art Generator использует **жадный алгоритм** (greedy algorithm) для генерации оптимального маршрута нити.

### Основной принцип

1. **Инициализация**: Начинается с гвоздя 0 (верхняя точка круга)
2. **Итерация**: На каждом шаге:
   - Оценивает все возможные линии от текущего гвоздя к остальным
   - Выбирает линию с максимальным "score" (покрывает наиболее темные области)
   - "Рисует" эту линию, уменьшая яркость пикселей
   - Переходит к выбранному гвоздю
3. **Остановка**: Алгоритм останавливается когда:
   - Достигнут лимит шагов (`NUM_STEPS`)
   - Остаточное изображение стало достаточно светлым (`RESIDUAL_THRESHOLD`)
   - Нет улучшений в течение `MAX_NO_IMPROVE` шагов

## Структура кода

```
string_art.py
│
├─ CONFIGURATION (строки 20-68)
│  └─ Все настраиваемые параметры
│
├─ NAIL GENERATION (строки 70-95)
│  └─ generate_nails(): Генерация позиций гвоздей
│
├─ IMAGE PREPROCESSING (строки 97-151)
│  ├─ preprocess_image(): Загрузка и обработка
│  └─ enhance_contrast(): Увеличение контраста
│
├─ LINE DRAWING AND SCORING (строки 153-261)
│  ├─ get_line_pixels(): Алгоритм Брезенхема
│  ├─ score_line(): Оценка качества линии
│  └─ draw_line(): Рисование линии
│
├─ STRING ART ALGORITHM (строки 263-350)
│  └─ simulate_string_art(): Основной алгоритм
│
├─ OUTPUT GENERATION (строки 352-640)
│  ├─ export_scheme_as_png(): Схема в PNG
│  ├─ export_scheme_as_pdf(): Схема в PDF
│  ├─ export_instructions_csv(): CSV инструкции
│  ├─ export_instructions_txt(): TXT инструкции
│  └─ render_drawing_simulation(): Симуляция результата
│
└─ MAIN PROGRAM (строки 642-733)
   └─ main(): Точка входа
```

## Ключевые компоненты

### 1. Генерация позиций гвоздей

```python
def generate_nails(num_nails, radius, center_x, center_y)
```

- Распределяет гвозди равномерно по окружности
- Начинает с верхней точки (90°) для интуитивного гвоздя 0
- Возвращает массив координат (x, y)

**Математика:**
```
angle = π/2 + (2π × i / num_nails)
x = center_x + radius × cos(angle)
y = center_y + radius × sin(angle)
```

### 2. Предобработка изображения

```python
def preprocess_image(image_path, target_size, invert)
```

**Шаги:**
1. Загрузка изображения
2. Конвертация в градации серого
3. Обрезка до квадрата (центрированная)
4. Изменение размера до `TARGET_SIZE`
5. Нормализация к диапазону [0.0, 1.0]
6. Инверсия (опционально): тёмные области → высокие значения
7. Увеличение контраста

**Инверсия:**
- `invert=True`: темные области получают больше нитей
- Формула: `img_array = 1.0 - img_array`

### 3. Алгоритм Брезенхема

```python
def get_line_pixels(x0, y0, x1, y1)
```

Классический алгоритм для получения всех пикселей вдоль линии:
- Эффективный (без вычислений с плавающей точкой)
- Используется для оценки и рисования линий

### 4. Оценка линии (Scoring)

```python
def score_line(img_array, x0, y0, x1, y1, line_weight)
```

**Принцип:**
- Суммирует яркость всех пикселей вдоль линии
- Высокий score = линия покрывает много темных областей
- Формула: `score = Σ pixel_values`

### 5. Рисование линии

```python
def draw_line(img_array, x0, y0, x1, y1, strength, line_weight)
```

**Принцип:**
- Уменьшает яркость пикселей вдоль линии
- Имитирует наложение нити
- Формула: `pixel = max(0, pixel - strength)`
- Clamp к [0.0, 1.0] для предотвращения отрицательных значений

### 6. Основной алгоритм симуляции

```python
def simulate_string_art(img_array, nails, num_steps, thread_strength, line_weight)
```

**Псевдокод:**
```
current_nail = 0
instructions = []
working_image = copy(target_image)

for step in 1..NUM_STEPS:
    best_score = -1
    best_nail = -1
    
    for each nail:
        if nail == current_nail: continue
        
        score = score_line(working_image, current_nail, nail)
        
        if score > best_score:
            best_score = score
            best_nail = nail
    
    if no improvement:
        break
    
    draw_line(working_image, current_nail, best_nail)
    instructions.append((current_nail, best_nail))
    current_nail = best_nail
    
    if working_image is mostly blank:
        break

return instructions
```

**Оптимизации:**
- **AUTO_STOP**: Автоматическая остановка при достижении оптимума
- **RESIDUAL_THRESHOLD**: Порог для определения "пустого" изображения
- **MAX_NO_IMPROVE**: Остановка при отсутствии улучшений

### 7. Экспорт схемы гвоздей

```python
def export_scheme_as_pdf/png(...)
```

**Особенности:**
- Масштабирование из пиксельного пространства в физическое (мм)
- Адаптивный размер шрифта на основе количества гвоздей
- Выделение каждого N-го гвоздя (красный цвет)
- Направляющие линии каждые 30° для точного размещения
- Белые рамки вокруг номеров для читаемости
- Красная звезда на гвозде 0 (начальная точка)
- Физические размеры на схеме

**Масштабирование:**
```
scale = drawable_size_px / TARGET_SIZE
x_plot = x * scale + offset_x
y_plot = y * scale + offset_y
```

### 8. Экспорт CSV инструкций

```python
def export_instructions_csv(instructions, nails, filename)
```

**Расчеты:**
- **Длина сегмента**: Евклидово расстояние в мм
  ```
  length_px = √((x1-x0)² + (y1-y0)²)
  length_mm = length_px × px_to_mm_scale
  ```
- **Угол**: arctg2 для определения направления (0-360°)
- **Прогресс**: (step / total_steps) × 100
- **Секция**: Разбивка на 10 частей для удобства
- **Общая длина**: Сумма всех сегментов + 20% запас

### 9. Симуляция финального результата

```python
def render_drawing_simulation(instructions, nails, canvas_size, filename, dpi)
```

**Техника:**
- RGBA холст с цветом бумаги
- Альфа-блендинг для реалистичного наложения нитей
- Низкая альфа (15/255) × много слоёв = реалистичное затемнение
- Периодическое композитирование (каждые 500 линий)
- Гвозди рисуются поверх нитей
- Красный маркер начала (гвоздь 0)

**Альфа-композитинг:**
```
result = (fg × alpha) + (bg × (1 - alpha))
```

## Параметры и их влияние

### NUM_NAILS (количество гвоздей)
- **Влияние на детализацию**: Больше гвоздей → больше возможных направлений → выше детализация
- **Влияние на сложность**: O(n²) на каждой итерации (n = NUM_NAILS)
- **Рекомендации**: 150-250 для баланса

### NUM_STEPS (количество шагов)
- **Влияние на полноту**: Больше шагов → более полное покрытие
- **Влияние на время**: Линейное увеличение времени выполнения
- **Рекомендации**: 2000-5000 в зависимости от изображения

### TARGET_SIZE (размер обработки)
- **Влияние на качество**: Больше → выше точность оценки линий
- **Влияние на память**: Квадратичное (TARGET_SIZE²)
- **Влияние на скорость**: Квадратичное увеличение
- **Рекомендации**: 600-1200

### THREAD_STRENGTH (сила нити)
- **Влияние на контраст**: Выше → темнее результат
- **Диапазон**: 0.15-0.30 оптимально
- **Настройка**: Зависит от контраста входного изображения

### LINE_WEIGHT (толщина линии)
- **Влияние на покрытие**: Влияет на оценку score
- **Настройка**: 10-15 для большинства случаев

## Сложность алгоритма

### Временная сложность
- **Предобработка**: O(TARGET_SIZE²)
- **Генерация гвоздей**: O(NUM_NAILS)
- **Основной цикл**: O(NUM_STEPS × NUM_NAILS × line_length)
  - NUM_STEPS итераций
  - NUM_NAILS оценок на каждой итерации
  - line_length пикселей в каждой линии
- **Итого**: O(NUM_STEPS × NUM_NAILS × TARGET_SIZE)

### Пространственная сложность
- **Рабочее изображение**: O(TARGET_SIZE²)
- **Массив гвоздей**: O(NUM_NAILS)
- **Инструкции**: O(NUM_STEPS)
- **Итого**: O(TARGET_SIZE²)

## Ограничения и компромиссы

### Жадный алгоритм
- **Преимущества**: Быстрый, простой, даёт хорошие результаты
- **Недостатки**: Не гарантирует глобальный оптимум
- **Альтернативы**: Генетические алгоритмы, имитация отжига (медленнее)

### Одноцветная нить
- Текущая версия оптимизирована для одного цвета нити
- Многоцветный string art требует отдельных слоёв для каждого цвета

### Круглая форма
- Гвозди размещаются только на окружности
- Другие формы (квадрат, сердце) требуют модификации

## Возможные улучшения

### Алгоритмические
1. **Локальная оптимизация**: Пересмотр последних N шагов
2. **Beam search**: Рассмотрение нескольких лучших вариантов
3. **Adaptive parameters**: Динамическое изменение THREAD_STRENGTH

### Функциональные
1. **Многоцветный string art**: Отдельные слои для каждого цвета
2. **Другие формы**: Квадрат, прямоугольник, сердце
3. **Переменная плотность гвоздей**: Больше в областях с деталями

### Производительность
1. **Параллелизация**: Оценка линий параллельно
2. **Кеширование**: Кеш координат линий
3. **GPU ускорение**: Использование CUDA для оценки линий

## Зависимости

### NumPy
- Векторные операции над изображениями
- Математические функции (cos, sin, arctan2)
- Массивы координат

### Pillow (PIL)
- Загрузка изображений
- Преобразование форматов
- Рисование на холсте (альфа-блендинг)

### Matplotlib
- Генерация схем PDF/PNG
- Графики и визуализация
- Экспорт в высоком разрешении

## Тестирование

### Рекомендуемые тестовые изображения
1. **Высокий контраст**: Логотипы, силуэты
2. **Средний контраст**: Портреты
3. **Низкий контраст**: Пейзажи

### Контрольные параметры
- Проверка валидации входных данных
- Тест на крайних случаях (NUM_NAILS=10, NUM_STEPS=100)
- Тест производительности (TARGET_SIZE=2000)

## Лицензия

MIT License - свободное использование для личных и коммерческих проектов.

## Контакты

При вопросах по технической реализации, обращайтесь к исходному коду и комментариям.
